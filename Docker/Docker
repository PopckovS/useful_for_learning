/** Docker **/
https://hub.docker.com/ - Официальный сайт Доккер Хаба

Правильный docker путь - минимально необходимое для запуска контейнера, находится в нутри него и только
    все отсальное кладется в нутрь других контейнеров, после чего между ними осуществляется взаимосвязь,
    Можно собрать в одном контейнере множество разных образов, но это не правильный путь. Правильно управлять
    множеством мальньких контейнеров.

Контейнер - Это процесс, у него своя сеть, свой список процессво в нутри, своя файловая система.
    Образ - Это отдельная виртуальная файловая система, к которой подключается процесс, и исполняет ее.

При выводе списка образов:
    Можно увидеть их теги TAG - которые укказываеют на версию образа который был локально установлен.
    Степень версии определяется по соответствию с DockerHub.
    Используя тег версии, мы можем использовать Docker с указанием на версию образа.
    >> docker run -it nginx:latest
        Запустить в работу сервер nginx из локальных образов, последней версии.
    >> dicker run -it php:7.1-cli

Управления контейнерами:
    >> create  - если в место "docker run" запустить "docker create" то контейнер будет собран но не запущен.
    >> running - это запущенный контейнер, если использовать команду "docker run" то контейнер будет с начала создан
                 как при "docker create" и после запущен в работу.
    >> paused  - можно остановить контейнер "docker paused"
    >> unpause - снова запустить контейнер  "docker unpause"
    >> stop    - контейнер остановлен, это может произойти из-за разных причин,
                 "docker kill", "docker stop", из за сбоя в основном окружении.
    >> deleted - удаление контейнера, при помощи "docker rm".



    =================== /** Comands for Docker **/ ===================
>>  docker run -it bash
    Скачать образ оболочки bash, -it дать возможность интерактивного воздействия с системой,
    и запустить контейнер на этой основе,

>>  docker run nginx
    Скачать образ сервера nginx запустить его контейнер,
    но не взаимодействовать с ним.

>>  docker run -p 8080:80 nginx
    Скачать образ сервера nginx запустить его контейнер,
    -p 8080:80 пробросить порт из контейнера в основную систему
    отобразить из нутриконтейнера порт 80 на порт 8080 основной системы.
    При этом вся отладочная инф будет выводится в терминал

>>  docker run -p 8080:80 -d nginx
    Сделать тоже самое, но -d делать это в фоновом режиме не блокируя терминал

>>  docker ps
    Вывести все процессы что происходят в нутри контейнеров,
    по сути это эквивалентно команде "sudo docker container ls"

>>  docker container ls
    Псевдоним для команды "sudo docker ps"

>>  docker ps -a
    Отобразить все процессы что когда либо были запущены на машине за все время
    При этом выводится отладочная информация о том как были завершены процессы.
    Одним из которых является STATUS:
        Exited(0)   - указывает как был завершен процесс работы, 0 - выход по желанию пользователя.
        Exited(100) - 100 ошибка, неполучилось получить доступ к репе с обновлениями для системы.

>>  rmi
    Удаляет образ, но только если нету запущенного контейнера на его базе, еслиже
    он есть, то удаление надо сдлеать при помощи доп.флага -f что означает, через силу.

>>  docker kill CONTAINER_ID
    Эта комнанда удаляет контейнер по его ID.

>>  docker pause CONTAINER_ID
    остановить работу контейнера, предварительно посмотриим ID нашего контейнера при помощи
    команды "docker ps" найдем его ID и по нему остановим работу контейнера.
    При этом если в нутри контейнера был запущен к примеру "docker run -p 8080:80 nginx"
    То сервер nginx заморозит свою работу, сервер прсото уйдет на бесконечное ожидание.

>>  docker unpause CONTAINER_ID
    Возобновить работу контейнера.

>>  docker stop CONTAINER_ID
    Существует некотрая разница между "pause" и "stop" при остановки контейнера именно командой STOP
    если в контейнере были запущены процессы типа сервера nginx, то работа сервера не войдет в цикл а
    полностью остановится. При этом команда "docker ps" что обычно выводит статус контейнеров,
    ничего не покажет, ибо конртейнер именно остановлен, по этому чтобы увидеть состояние контейнера надо
    использовать команду "docker ps -a" именно с ключем -a тоесть отобразить все контейнеры.
    а в статусе состояния будет указано нечто вроде:
    "Exited (0) 5 seconds ago" тоесть,  контейнер остановлен без ошибок, 5 секунд назад.

>>  docker start CONTAINER_ID
    Запустить работу контейнера.

>>  docker logs CONTAINER_ID
    Когда мы запускаем контейнер с сервером nginx, то видим логи что приходят в терминал,
    Можно использывать опцию -d для того чтобы сервер работал в фоновом режиме, и не блокировал терминал
    "docker logs CONTAINER_ID" эта команда выводит логи контейнера в терминал по ID запущенного контейнера.
    Если использовать опцию -f это выглядит так "docker logs -f CONTAINER_ID" то терминал начнет выводить
    отладочную информацию в режиме реального времени.

>>  docker stats
    Показать по каждому контейнеру сколько памяти он употребляет и разную отладочную информацию.

>>  docker pull nginx
    Скачать образ для контейнера, только скачать, не запустить контейнер только скачать их репы.
    По дефолту скачивает образ из официального репозитория DockerHub.
    Но можно указать и свой репозиторий для скачивания вот этой командой.
    docker pull myreg:port/my/nginx


 ================== /** Взаимодействие контейнера с внешним миром **/ ==================
 Это можно сделать 2 разными способами
 1 - Сеть
 2 - Файлы
 3 - Установка переменных окружения (односторонний метод взаимодействия с контейнером)

 Сеть - это проброска портов, мы можем указать какой порт внутри контейнера, соответствует нашему порту
 на нашей машине которая контейнер запускает.

1 - СЕТЬ

>>  docker run -p 80:80 -p 443:443 nginx
    Эта команда позволяет вывести на ружу сразу 2 порта.
    80 - http
    443 - https
    В результате контейнер становится доступен по сети, но !!! у контейнера нету своего IP адресса,
    в отличии от виртуальной машины(у котрой есть свой собственный IP адресс) у контейнера его нету.
    Контейнер - это прсото изолированный процесс, без своего IP.
    Тоесть у контейнера нету своего IP адреса, но есть технология маппинга портов,

2 - ФАЙЛЫ
    Второй вариант, это возможность пробросить что-то в нутрь, при запуске "docker run"
    есть возможность, указать соответствие папок или конкретных файлов.

>>  docker run -p 8080:80 -v /var/www:/app nginx
    Запускаем контейнер nginx, пробрасываем порт, и при помощи специально опции -v
    Указываем какая папка в нашей системе соответсвует папке в нутки контейнера,
    /var/www:/app - Это означает что наша директория с хостами /var/www имеет полное отображение
    с директорией /app в нутри нашего контейнера.
    При этом указание путей должно быть абсолютным, иначе получим ошибку при запуске контейнера.
    Ошибка такого образца:
    "docker: Error response from daemon: invalid volume specification: '/var/www:app':
    invalid mount config for type "bind": invalid mount path: 'app' mount path must be absolute."

>>  docker exec -it CONTAINER_ID bash
    И так мы запустили контейнер с nginx в нутри, пробросили порты, отобразили фалы.
    Далее нам надо попасть в нутрь контейнера и посмотреть, действительно ли наши фалйы доступны в нутри
    нашего контейнера. Делаем это выше указанной командой, которая голворит, выполни интерактивную работу
    с этим контейнером, запусти в нутри него интерпретатор програмной оболочки bash.
    В результате ее исполнения мы попадаем в нутрь контейнера, и перейдя в нутрь папки app
    увидим все теже папки, с темже содержимым в нутри, что и в нашей директории /var/www

    При этом физически фалы находятся на нашей основнйо системе, но взаимодействовать с ними мы можем
    из нутри нашего контейнера.

3 - Установка переменных окружения
    Можно установить как одну переменную, при помощи ключа -e "HOME=/app" nginx
    Либо перечислить свои переменные в файле, и указать сразу целый фал с набором переменнны,

>>  docker run -e "HOME=/app" nginx
    Установка одной переменной

>>  docker run --env-file=/env nginx
    Установка целого файла с переменными



 ====================== /** Как сделать свой собственный образ **/ =====================
 Иногда подготовленных образов в контейнере нехватает, и тогда можно создать свой собственный образ.
 К примеру, создаем "docker run -it php:7.1-cli bash" и проверяем есть ли в нутри него composer.
 его там нету, и тогда можно поступить следующим образом.
 Наследуемся от образа и добавляем в него чтото дополнительное, к примеру composer.

 И так как это сделать:
 Создаем свой фал который называется Dockerfile - это по сути описание того что мы хотим сделать.

 Dockefile:

    FROM php:7.3-cli
        FROM - Это первое слово с которого должен начинаться фалй, оно указывает какой образ
        брать за основу для работы

    MAINTAINER Sergio Popckov
        MAINTAINER - указывает разработчиков данного образа, не обезательный параметр.

    COPY ./app
        COPY - При сборки образа можно сразу указать, что из текущей папки(тоесть той в кот-й Dockerfile)
        мы все копируем в папку ./app
        Тоесть на данный момент это значит что, данный образ не отличается ничем кроме того что у него в нутри
        будет доп папка ./app в который будет скопированы папки из директории app

    WORKDIR /app
        WORKDIR - указать рабочую директорию

    RUN apt update
    RUN apt install composer
        RUN - Создает новый слой, каждый контейнер можно себе представить в виде множества слоев,
        Слой - это коммит, похожий на коммиты в git, эта команда по мимо существующих слоев строит еще один.
        Тоесть до команды RUN наш образ езще ни чем не отличался от базавого, но после него наш образ изменится.
        И теперь после этих команд наш образ будет отличаться от базавого, тем что у него произошло
        обновление системы, и установился composer.

>>  docker build ./
    После все этого, мы собираем образ при помощи этой команды
